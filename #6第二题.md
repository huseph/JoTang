# 递归dp与递推dp #

## 遇到问题 ##

最初以为是暴力背包，351 * 41 * 41 * 41 * 41发现这个dp数组有点大，决定优化，但这个背包和别的背包不一样的在于卡片的使用先后顺序是影响卡片的价值的，虽然不知道到这个算不算“后效性”，但是总之普通的多重背包的状态转移方程是不行了的。

发现了卡片必会用完这特性，但是并不知道怎么使用。我决定从根本改变这个题目做法方向，而不是着手状态转移方程（因为我感觉普通套路几个for循环套起来一个转移方程并不能解决这个问题，因为卡片先后用有区别。）所以我想到把这个线的图通过dfs遍历成为链表，然后再用大家学dp第一个题目那种从下往上简单dp就好了，但是这个链表似乎有点大啊最多4^40个末梢？？但是显然过程中有些用了一样多的卡却走了更烂的路的节点是废的，这咋弄？再中间怎么判断？不知如何解决

## 解决问题 ##

只好选择使用递归的方法，递归在这里的优势在于，它本身的实现过程中就是我类似上文所说的那种形成表并且边dp的，因为递归函数中就是分叉然后选最好的。（而且dfs不也是用递归? ~~也许递归dp这种神奇的方法就是某大佬像我上面那样想边dfs边dp而发明的？~~） 坦白说，递归解决dp这种方法我是第一次见到，说实话这个代码也是与1607班的唐伟翔交流后从他那里学到的（说难听点就是抄到的，毕竟这题就这一两句核心）。但是我觉得我的思路已经从递推dp无限接近了递归dp这边，也算是被他助攻了临门一脚吧（强行）~~（要不然我是不是要自己发明递归dp了？）~~。不知道这算不算抄袭哎……

## 真·解决问题！！！ ##

我终于做出来了！！

### 几个关键：

第一个：我摒弃了用距离来做索引的想法，因为卡牌使用情况本身就包含着距离信息，所以只需要四位数组记录各个卡片使用多少张的时候所能取得的最多萝卜就好了。这时状态转移方程就显然了——当前使用情况的最好结果为各个卡片分别少用一张的最好情况加当前使用情况对应的格子的萝卜数！

第二个：第一个萝卜默认获取，所以把总格子数其实减一，第一个格子的萝卜数直接单独读进来当作dp[0] [0] [0] [0]的初始值。

第三个：也是最重要的一个，不要把问题复杂化，多元化考虑问题，做惯了根据距离dp的，还有背包dp，被容量和距离蒙蔽了双眼。其实这个就是根据卡片使用情况的很朴实的dp。



*~~哈哈哈twx同学在状态转移方程中[i] [j] [k] [l] 打成[i] [j] [l] [l] debug半个多小时哈哈哈哈哈~~*